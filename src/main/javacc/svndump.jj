options {
    STATIC = false;
    JAVA_UNICODE_ESCAPE = false;
    USER_CHAR_STREAM = true;
}

PARSER_BEGIN(SvnDumpFileParser)
  package com.github.cstroe.svndumpgui.generated;

  import java.io.InputStreamReader;
  import java.io.PrintStream;
  import java.io.IOException;
  import java.io.ByteArrayOutputStream;
  import java.io.UnsupportedEncodingException;
  import java.util.Map;
  import java.util.LinkedHashMap;

  import com.github.cstroe.svndumpgui.api.SvnDump;
  import com.github.cstroe.svndumpgui.api.SvnDumpConsumer;
  import com.github.cstroe.svndumpgui.api.SvnDumpPreamble;
  import com.github.cstroe.svndumpgui.api.SvnDumpWriter;
  import com.github.cstroe.svndumpgui.api.SvnNode;
  import com.github.cstroe.svndumpgui.api.SvnNodeHeader;
  import com.github.cstroe.svndumpgui.api.SvnRevision;
  import com.github.cstroe.svndumpgui.internal.SvnDumpImpl;
  import com.github.cstroe.svndumpgui.internal.SvnDumpPreambleImpl;
  import com.github.cstroe.svndumpgui.internal.SvnDumpWriterImpl;
  import com.github.cstroe.svndumpgui.internal.SvnNodeImpl;
  import com.github.cstroe.svndumpgui.internal.SvnRevisionImpl;
  import com.github.cstroe.svndumpgui.internal.utility.FastCharStream;
  import com.google.common.base.Stopwatch;

  public class SvnDumpFileParser {
    public static void main(String[] args)
    throws ParseException, TokenMgrError, UnsupportedEncodingException {
      SvnDumpFileParser parser = new SvnDumpFileParser(new FastCharStream(new InputStreamReader(System.in, "ISO-8859-1")));
      SvnDumpWriter writer = new SvnDumpWriterImpl();
      writer.writeTo(System.out);
      parser.Start(writer);
    }

    private String readCharacters(Integer number) {
      if(number == null) {
        return null;
      }
      StringBuilder sb = new StringBuilder();
      for(int i = 0; i < number; i++) {
          try {
            sb.append(token_source.input_stream.readChar());
          }
          catch(IOException ex) {}
      }
      return sb.toString();
    }

    public static String humanReadableByteCount(long bytes, boolean si) {
        int unit = si ? 1000 : 1024;
        if (bytes < unit) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(unit));
        String pre = (si ? "kMGTPE" : "KMGTPE").charAt(exp-1) + (si ? "" : "i");
        return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre);
    }

    private byte[] readByteArray(Integer length) {
        if(length == null) {
            return null;
        }

        System.err.print("Reading " + humanReadableByteCount((long)length, false) + " ... ");
        Stopwatch stopwatch = new Stopwatch().start();

        ByteArrayOutputStream baos = new ByteArrayOutputStream(length);
        for(int i = 0; i < length; i++) {
            try {
              baos.write(token_source.input_stream.readChar());
            }
            catch(IOException ex) {}
        }

        try {
            baos.flush();
        } catch(IOException ex) {
            // should not happen
        }
        System.err.println("done in " + stopwatch.toString());

        return baos.toByteArray();
    }

  }
PARSER_END(SvnDumpFileParser)

//  Lexer

SKIP: { " " }
TOKEN: { <EOL: "\n" | "\r" | "\r\n"> }
TOKEN: { <NUMBER: (["0"-"9"])+> }
TOKEN: { <  COLON: ":"> }
TOKEN: { <VERSION_KEY: "SVN-fs-dump-format-version"> }
TOKEN: { <UUID_KEY: "UUID"> }
TOKEN: { <UUID_VALUE: (["0"-"9","a"-"z"]){8} "-" (["0"-"9","a"-"z"]){4} "-" (["0"-"9","a"-"z"]){4} "-" (["0"-"9","a"-"z"]){4} "-" (["0"-"9","a"-"z"]){12}> }
TOKEN: { <REVISION_NUMBER_KEY: "Revision-number"> }
TOKEN: { <PROP_CONTENT_LENGTH_KEY: "Prop-content-length"> }
TOKEN: { <CONTENT_LENGTH_KEY: "Content-length"> }

TOKEN: { <KEY: "K"> }
TOKEN: { <VAL: "V"> }
TOKEN: { <PROPS_END: "PROPS-END"> }

TOKEN: { <NODE_PATH_KEY: "Node-path: "> : READ_PATH }
TOKEN: { <NODE_KIND_KEY: "Node-kind"> }
TOKEN: { <NODE_KIND_VALUE: ("file"|"dir")> }
TOKEN: { <NODE_ACTION_KEY: "Node-action"> }
TOKEN: { <NODE_ACTION_VALUE: ("change" | "add" | "delete" | "replace")> }
TOKEN: { <NODE_COPYFROM_REV_KEY: "Node-copyfrom-rev"> }
TOKEN: { <NODE_COPYFROM_PATH_KEY: "Node-copyfrom-path: "> : READ_PATH }

TOKEN: { <TEXT_CONTENT_LENGTH_KEY: "Text-content-length"> }
TOKEN: { <TEXT_CONTENT_MD5_KEY: "Text-content-md5"> }
TOKEN: { <MD5_VALUE: (["0"-"9","a"-"z"]){32}> }
TOKEN: { <TEXT_CONTENT_SHA1_KEY: "Text-content-sha1"> }
TOKEN: { <SHA1_VALUE: (["0"-"9","a"-"z"]){40}> }
TOKEN: { <TEXT_COPYSOURCE_MD5_KEY: "Text-copy-source-md5"> }
TOKEN: { <TEXT_COPYSOURCE_SHA1_KEY: "Text-copy-source-sha1"> }

<READ_PATH> TOKEN: { <NODE_PATH_VALUE: (~["\n","\r"])*> : DEFAULT }

// Parser

public void Start(SvnDumpConsumer consumer):
{
  Token dumpVersion;
  Token uuid;
  SvnRevision revision;
  Stopwatch stopwatch;
}
{
    {
        stopwatch = new Stopwatch().start();
    }

    <VERSION_KEY> <COLON> dumpVersion = <NUMBER> <EOL>
    <EOL>

    <UUID_KEY> <COLON> uuid = <UUID_VALUE> <EOL>
    <EOL>

    {
        if(uuid != null) {
            SvnDumpPreamble preamble = new SvnDumpPreambleImpl(uuid.image);
            consumer.consume(preamble);
        }
    }

    (
        revision = Revision()
        {
            System.err.println(stopwatch.toString() + ": Consuming revision " + revision.getNumber());
            consumer.consume(revision);
            revision = null;
        }
    )*

    <EOF>
}

public SvnRevision Revision():
{
    SvnRevisionImpl revision;
    Token revisionNumber;
    Token contentLength;
    Map properties;
    SvnNode node;
}
{
    <REVISION_NUMBER_KEY> <COLON> revisionNumber = <NUMBER> <EOL>

    ( <PROP_CONTENT_LENGTH_KEY> <COLON> <NUMBER> <EOL> )?

    <CONTENT_LENGTH_KEY> <COLON> contentLength = <NUMBER> <EOL>
    <EOL>

    { revision = new SvnRevisionImpl(Integer.parseInt(revisionNumber.image)); }

    properties = Property()
    { revision.setProperties(properties); }

    (
        node = Node()
        { revision.addNode(node); }
        |
        <EOL>
    )*

    { return revision; }
}

public Map Property():
{
    Map properties = new LinkedHashMap();
    String key, value;
    Token keyLength, valueLength;
}
{
    (
        <KEY> keyLength = <NUMBER> <EOL>
        { key = readCharacters(Integer.parseInt(keyLength.image)); }
        <EOL>

        <VAL> valueLength = <NUMBER> <EOL>
        { value = readCharacters(Integer.parseInt(valueLength.image)); }
        <EOL>

        {
            properties.put(key, value);
        }
    )*

    <PROPS_END> <EOL>

    { return properties; }
}

public SvnNode Node():
{
    SvnNodeImpl svnNode;
    Token nodePath = null;
    Token nodeKind = null;
    Token nodeAction = null;
    Token nodeMd5 = null;
    Token nodeSha1 = null;
    Token contentLength = null;
    Token textContentLength = null;
    Token propContentLength = null;
    Token copiedFromRevision = null;
    Token copiedFromPath = null;
    Token copiedFromMd5 = null;
    Token copiedFromSha1 = null;
    Map headers = new LinkedHashMap();
}
{
    (
        <NODE_PATH_KEY> nodePath = <NODE_PATH_VALUE> <EOL>
        {
            headers.put(SvnNodeHeader.PATH, nodePath.image);
        }
    |
        <NODE_KIND_KEY> <COLON> nodeKind = <NODE_KIND_VALUE> <EOL>
        {
            headers.put(SvnNodeHeader.KIND, nodeKind.image);
        }
    |
        <NODE_ACTION_KEY> <COLON> nodeAction = <NODE_ACTION_VALUE> <EOL>
        {
            headers.put(SvnNodeHeader.ACTION, nodeAction.image);
        }
    |
        <PROP_CONTENT_LENGTH_KEY> <COLON> propContentLength = <NUMBER> <EOL>
        {
            headers.put(SvnNodeHeader.PROP_CONTENT_LENGTH, propContentLength.image);
        }
    |
        <TEXT_CONTENT_LENGTH_KEY> <COLON> textContentLength = <NUMBER> <EOL>
        {
            headers.put(SvnNodeHeader.TEXT_CONTENT_LENGTH, textContentLength.image);
        }
    |
        <TEXT_CONTENT_MD5_KEY> <COLON> nodeMd5 = <MD5_VALUE> <EOL>
        {
            headers.put(SvnNodeHeader.MD5, nodeMd5.image);
        }
    |
        <TEXT_CONTENT_SHA1_KEY> <COLON> nodeSha1 = <SHA1_VALUE> <EOL>
        {
            headers.put(SvnNodeHeader.SHA1, nodeSha1.image);
        }
    |
        <CONTENT_LENGTH_KEY> <COLON> contentLength = <NUMBER> <EOL>
        {
            headers.put(SvnNodeHeader.CONTENT_LENGTH, contentLength.image);
        }
    |
        <NODE_COPYFROM_REV_KEY> <COLON> copiedFromRevision = <NUMBER> <EOL>
        {
            headers.put(SvnNodeHeader.COPY_FROM_REV, copiedFromRevision.image);
        }
    |
        <NODE_COPYFROM_PATH_KEY> copiedFromPath = <NODE_PATH_VALUE> <EOL>
        {
            headers.put(SvnNodeHeader.COPY_FROM_PATH, copiedFromPath.image);
        }
    |
        <TEXT_COPYSOURCE_MD5_KEY> <COLON> copiedFromMd5 =  <MD5_VALUE> <EOL>
        {
            headers.put(SvnNodeHeader.SOURCE_MD5, copiedFromMd5.image);
        }
    |
        <TEXT_COPYSOURCE_SHA1_KEY> <COLON> copiedFromSha1 =  <SHA1_VALUE> <EOL>
        {
            headers.put(SvnNodeHeader.SOURCE_SHA1, copiedFromSha1.image);
        }
    )+

    <EOL>

    {
        svnNode = new SvnNodeImpl();
        svnNode.setHeaders(headers);
        headers = null;

        if(propContentLength != null) {
            svnNode.setProperties(Property());
        }

        if(textContentLength != null) {
            svnNode.setContent(readByteArray(Integer.parseInt(textContentLength.image)));
        }
    }

    { return svnNode; }
}