options {
    STATIC = false;
    UNICODE = false;
    JAVA_UNICODE_ESCAPE = false;
}

PARSER_BEGIN(SvnDumpFileParser)
  package com.github.cstroe.svndumpgui.generated;

  import java.io.PrintStream;
  import java.io.IOException;
  import java.io.ByteArrayOutputStream;
  import java.util.Map;
  import java.util.HashMap;

  import com.github.cstroe.svndumpgui.api.SvnDump;
  import com.github.cstroe.svndumpgui.api.SvnRevision;
  import com.github.cstroe.svndumpgui.api.SvnNode;
  import com.github.cstroe.svndumpgui.internal.SvnRevisionImpl;
  import com.github.cstroe.svndumpgui.internal.SvnDumpImpl;
  import com.github.cstroe.svndumpgui.internal.SvnRevisionImpl;
  import com.github.cstroe.svndumpgui.internal.SvnNodeImpl;

  public class SvnDumpFileParser {
    public static void main(String[] args)
    throws ParseException, TokenMgrError {
      SvnDumpFileParser parser = new SvnDumpFileParser(System.in);
      parser.Start();
    }

    private String readCharacters(Integer number) {
      if(number == null) {
        return null;
      }
      StringBuilder sb = new StringBuilder();
      for(int i = 0; i < number; i++) {
          try {
            sb.append(token_source.input_stream.readChar());
          }
          catch(IOException ex) {}
      }
      return sb.toString();
    }

    private byte[] readByteArray(Integer length) {
        if(length == null) {
            return null;
        }
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        for(int i = 0; i < length; i++) {
            try {
              baos.write((int)token_source.input_stream.readChar());
            }
            catch(IOException ex) {}
        }
        return baos.toByteArray();
    }

  }
PARSER_END(SvnDumpFileParser)

//  Lexer

SKIP: { " " }
TOKEN: { <EOL: "\n" | "\r" | "\r\n"> }
TOKEN: { <NUMBER: (["0"-"9"])+> }
TOKEN: { <COLON: ":"> }
TOKEN: { <VERSION_KEY: "SVN-fs-dump-format-version"> }
TOKEN: { <UUID_KEY: "UUID"> }
TOKEN: { <UUID_VALUE: (["0"-"9","a"-"z"]){8} "-" (["0"-"9","a"-"z"]){4} "-" (["0"-"9","a"-"z"]){4} "-" (["0"-"9","a"-"z"]){4} "-" (["0"-"9","a"-"z"]){12}> }
TOKEN: { <REVISION_NUMBER_KEY: "Revision-number"> }
TOKEN: { <PROP_CONTENT_LENGTH_KEY: "Prop-content-length"> }
TOKEN: { <CONTENT_LENGTH_KEY: "Content-length"> }

TOKEN: { <KEY: "K"> }
TOKEN: { <VAL: "V"> }
TOKEN: { <PROPS_END: "PROPS-END"> }

TOKEN: { <NODE_PATH_KEY: "Node-path: "> : READ_PATH }
TOKEN: { <NODE_KIND_KEY: "Node-kind"> }
TOKEN: { <NODE_KIND_VALUE: ("file"|"dir")> }
TOKEN: { <NODE_ACTION_KEY: "Node-action"> }
TOKEN: { <NODE_ACTION_VALUE: ("change" | "add" | "delete" | "replace")> }

TOKEN: { <TEXT_CONTENT_LENGTH_KEY: "Text-content-length"> }
TOKEN: { <TEXT_CONTENT_MD5_KEY: "Text-content-md5"> }
TOKEN: { <TEXT_CONTENT_MD5_VALUE: (["0"-"9","a"-"z"]){32}> }
TOKEN: { <TEXT_CONTENT_SHA1_KEY: "Text-content-sha1"> }
TOKEN: { <TEXT_CONTENT_SHA1_VALUE: (["0"-"9","a"-"z"]){40}> }

<READ_PATH> TOKEN: { <NODE_PATH_VALUE: (~["\n","\r"])+> : DEFAULT }

// Parser

public SvnDump Start():
{
  SvnDumpImpl dump = new SvnDumpImpl();
  Token dumpVersion;
  SvnRevision revision;
}
{
    <VERSION_KEY> <COLON> dumpVersion = <NUMBER> <EOL>
    <EOL>

    <UUID_KEY> <COLON> <UUID_VALUE> <EOL>
    <EOL>

    (
        revision = Revision()
        { dump.addRevision(revision); }
    )*

    <EOF>

    { return dump; }
}

public SvnRevision Revision():
{
    SvnRevisionImpl revision;
    Token revisionNumber;
    Token contentLength;
    Map properties;
    SvnNode node;
}
{
    <REVISION_NUMBER_KEY> <COLON> revisionNumber = <NUMBER> <EOL>

    ( <PROP_CONTENT_LENGTH_KEY> <COLON> <NUMBER> <EOL> )?

    <CONTENT_LENGTH_KEY> <COLON> contentLength = <NUMBER> <EOL>
    <EOL>

    { revision = new SvnRevisionImpl(Integer.parseInt(revisionNumber.image)); }

    properties = Property()
    { revision.setProperties(properties); }

    (
        node = Node()
        { revision.addNode(node); }
        |
        <EOL>
    )*

    { return revision; }
}

public Map Property():
{
    Map properties = new HashMap();
    String key, value;
    Token keyLength, valueLength;
}
{
    (
        <KEY> keyLength = <NUMBER> <EOL>
        { key = readCharacters(Integer.parseInt(keyLength.image)); }
        <EOL>

        <VAL> valueLength = <NUMBER> <EOL>
        { value = readCharacters(Integer.parseInt(valueLength.image)); }
        <EOL>

        {
            properties.put(key, value);
        }
    )*

    <PROPS_END> <EOL>

    { return properties; }
}

public SvnNode Node():
{
    SvnNodeImpl svnNode;
    Token nodePath = null;
    Token nodeKind = null;
    Token nodeAction = null;
    Token nodeMd5 = null;
    Token nodeSha1 = null;
    Token contentLength = null;
    Token textContentLength = null;
    Token propContentLength = null;
    byte[] fileContent = null;
    Map properties;
}
{
    (
        <NODE_PATH_KEY> nodePath = <NODE_PATH_VALUE> <EOL>
        |
        <NODE_KIND_KEY> <COLON> nodeKind = <NODE_KIND_VALUE> <EOL>
        |
        <NODE_ACTION_KEY> <COLON> nodeAction = <NODE_ACTION_VALUE> <EOL>
        |
        <PROP_CONTENT_LENGTH_KEY> <COLON> propContentLength = <NUMBER> <EOL>
        |
        <TEXT_CONTENT_LENGTH_KEY> <COLON> textContentLength = <NUMBER> <EOL>
        |
        <TEXT_CONTENT_MD5_KEY> <COLON> nodeMd5 = <TEXT_CONTENT_MD5_VALUE> <EOL>
        |
        <TEXT_CONTENT_SHA1_KEY> <COLON> nodeSha1 = <TEXT_CONTENT_SHA1_VALUE> <EOL>
        |
        <CONTENT_LENGTH_KEY> <COLON> contentLength = <NUMBER> <EOL>
    )+

    <EOL>

    {
        if(propContentLength != null) {
            properties = Property();
        }

        svnNode = new SvnNodeImpl();

        // required
        svnNode.setPath(nodePath.image);
        svnNode.setAction(nodeAction.image);

        // optional
        if(nodeKind != null) {
            svnNode.setKind(nodeKind.image);
        }
        if(nodeMd5 != null) {
            svnNode.setMd5(nodeMd5.image);
        }
        if(nodeSha1 != null) {
            svnNode.setSha1(nodeSha1.image);
        }
        if(textContentLength != null) {
            fileContent = readByteArray(Integer.parseInt(textContentLength.image));
            svnNode.setContent(fileContent);
        }
    }

    { return svnNode; }
}